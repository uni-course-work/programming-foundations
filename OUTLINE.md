# Programming Fundamentals with C++ - Course Outline

## **Module 1: Foundations and Mindset**
*Building the mental framework for programming*

### Chapter 1: Orientation and Expectations
- What you're assumed to know
- What success looks like
- Common beginner failure modes

### Chapter 2: What Programming Actually Is
- Giving precise instructions to machines
- Abstraction and translation
- Human intent vs. machine execution

### Chapter 3: Why Learn Programming Fundamentals (Even in the Age of AI)
- Why code generation doesn't replace understanding
- Transferable mental models
- Correctness, debugging, and performance reasoning

### Chapter 4: Why C++ Is Used Here
- C++ as a teaching instrument
- Exposure to memory and performance realities
- Trade-offs and limitations acknowledged

### Chapter 5: Programmer Mindset and Discipline
- Precision in thinking
- Comfort with failure
- Reading error messages
- "Working" code vs. correct code

---

## **Module 2: Problem-Solving and Development Process**
*How programmers think and work*

### Chapter 6: Computational Thinking
- Understanding problems
- Decomposition and pattern recognition
- Designing step-by-step procedures
- The full problem-solving cycle

### Chapter 7: Debugging as a Core Skill
- What bugs are and why they're inevitable
- Systematic debugging vs. guesswork
- Mental tracing and reasoning about program state
- Fault isolation

### Chapter 8: Development Environment and Toolchain
- Code editors and compilers
- The build process
- Understanding the compilation pipeline
- Where errors occur and why

---

## **Module 3: Core Programming Concepts**
*The building blocks of programs*

### Chapter 9: Anatomy of a Simple Program
- Program structure and the main entry point
- Statements and expressions
- Linear execution model
- Comments as human communication

### Chapter 10: Data, Values, and Types
- Programs as data manipulation
- Data types as constraints and interpretations
- Primitive numeric and character types
- Values, variables, and storage

### Chapter 11: Variables, Naming, and Lifetime
- Variables as named bindings
- Declaration and initialization
- Scope and lifetime
- Naming conventions for readability
- Common mistakes with uninitialized data

### Chapter 12: Input and Output Basics
- Program interaction with the outside world
- Streams and I/O concepts
- Why I/O is slower than computation
- Formatting as communication design

### Chapter 13: Operators and Expressions
- Expressions as computations producing values
- Arithmetic, relational, and logical operations
- Operator precedence as parsing rules
- Type conversion and pitfalls

---

## **Module 4: Control Flow**
*Making decisions and repeating actions*

### Chapter 14: Decision Making and Control Flow
- Branching logic and program state
- Conditional execution
- Boolean logic reasoning
- Mutually exclusive paths
- Exhaustive decision handling

### Chapter 15: Repetition and Iteration
- Loops as controlled repetition
- Loop purpose and termination conditions
- Loop invariants
- Choosing the right looping construct
- Practical applications: input validation and menus

---

## **Module 5: Program Structure and Organization**
*Managing complexity through decomposition*

### Chapter 16: Decomposition with Functions
- Functions as a response to complexity
- Enabling reuse, testing, and reasoning
- Parameters and return values
- Local scope
- Pass-by-value vs. pass-by-reference

---

## **Module 6: Working with Data**
*Organizing and modeling information*

### Chapter 17: Organizing Data Collections
- Collections of values
- Dynamic containers: safety and flexibility
- Iteration patterns
- Fixed-size arrays: comparison and use cases

### Chapter 18: Modeling Related Data with Structures
- Structures as simple data models
- Grouping related values
- Collections of structures
- Real-world data modeling
- Boundary with object-oriented design

### Chapter 19: Persistent Data and File Interaction
- Programs beyond single execution runs
- Why persistence matters
- Reading from and writing to files
- Text-based data formats

---

## **Module 7: Memory Concepts**
*Understanding how data lives in memory*

### Chapter 20: Memory, Addresses, and References
- References as aliases to existing data
- Memory addresses: abstract understanding
- How data is located and accessed
- Conceptual clarity without low-level manipulation

### Chapter 21: Pointers as a Model of Indirection
- Understanding indirection
- Dynamic allocation
- Ownership concepts
- Risks of misuse
- Alternatives and safer abstractions

---

## **Module 8: Professional Practices**
*Writing maintainable, correct code*

### Chapter 22: Program Correctness and Style
- Commenting strategy
- Code readability
- Consistent formatting
- Defensive programming
- Testing mindset
- Programs as artifacts meant to be maintained

---

## **Closing Perspective**
*Where to go from here*

- This foundation supports future learning
- Object-oriented design, generic programming, and modern C++
- Graduating as someone who understands what programs are
- The journey continues beyond this repository